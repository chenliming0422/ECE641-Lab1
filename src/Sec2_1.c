#include <math.h>
#include "lib\tiff.h"
#include "lib\allocate.h"
#include "lib\randlib.h"
#include "lib\typeutil.h"

void error(char *name);

int main (int argc, char **argv) 
{
    FILE *fp;
    struct TIFF_img input_img, output_img;
    double **img1, **img2, **perr;
    int32_t i,j, p,pixel;
    double sigma_ML[20] = {0.0};
    int M, N;

    if ( argc != 2 ) error( argv[0] );

      /* open image file */
    if ( ( fp = fopen ( argv[1], "rb" ) ) == NULL ) {
        fprintf ( stderr, "cannot open file %s\n", argv[1] );
        exit(1);
    }

    /* read image */
    if ( read_TIFF ( fp, &input_img ) ) {
        fprintf ( stderr, "error reading file %s\n", argv[1] );
        exit(1);
    }

    /* close image file */
     fclose ( fp );

    /* check the type of image data */
    if ( input_img.TIFF_type != 'g' ) {
        fprintf ( stderr, "error:  image must be gray scale\n" );
        exit ( 1 );
    }

    /* Allocate image of double precision floats */
    img1 = (double **)get_img(input_img.width,input_img.height,sizeof(double));
    img2 = (double **)get_img(input_img.width,input_img.height,sizeof(double));
    perr = (double **)get_img(input_img.width,input_img.height,sizeof(double));

    /* copy image pixels to double array */
    for ( i = 0; i < input_img.height; i++ )
    for ( j = 0; j < input_img.width; j++ ) {
        img1[i][j] = input_img.mono[i][j];
    }

    M = input_img.height;
    N = input_img.width;

    /* compute prediction generated by a GGMRF prediction filter */
    for ( i = 0; i < input_img.height; i++ )
    for ( j = 0; j < input_img.width; j++ ) {
        img2[i][j] = (1/6.0)*(img1[(i-1+M)%M][(j+N)%N] + img1[(i+1+M)%M][(j+N)%N] + img1[(i+M)%M][(j+1+N)%N] + img1[(i+M)%M][(j+1+N)%N]) 
                    + (1/12.0)*(img1[(i-1+M)%M][(j-1+N)%N] + img1[(i-1+M)%M][(j+1+N)%N] + img1[(i+1+M)%M][(j+1+N)%N] + img1[(i+1+M)%M][(j-1+N)%N]);
    }

    /* compute prediction error */
    for ( i = 0; i < input_img.height; i++ )
    for ( j = 0; j < input_img.width; j++ ) {
        perr[i][j] = img1[i][j] - img2[i][j] + 127;
    }

    /* set up structure for output achromatic image */
    /* to allocate a full color image use type 'c' */
     get_TIFF ( &output_img, input_img.height, input_img.width, 'g' );

    for ( i = 0; i < input_img.height; i++ )
    for ( j = 0; j < input_img.width; j++ ) {
        pixel = (int32_t)perr[i][j];
        if(pixel > 255) pixel = 255;
        if(pixel < 0) pixel = 0;
        output_img.mono[i][j] = pixel;
    }

    /* open output image file */
    if ( ( fp = fopen ( "perr.tif", "wb" ) ) == NULL ) {
        fprintf ( stderr, "cannot open file perr.tif\n");
        exit ( 1 );
    }

    /* write output image */
    if ( write_TIFF ( fp, &output_img ) ) {
        fprintf ( stderr, "error writing TIFF file" );
        exit ( 1 );
    }

    /* close output image file */
    fclose ( fp );

    /* compute sigma_ML^p */
    for ( p = 1; p <= 20; p++){
        for ( i = 1; i < input_img.height-1; i++ )
        for ( j = 1; j < input_img.width-1; j++ ) {
            sigma_ML[p] += (1/6.0) * (pow(fabs(img1[i][j] - img1[i-1][j]), p*0.1) 
                                  + pow(fabs(img1[i][j] - img1[i+1][j]), p*0.1) 
                                  + pow(fabs(img1[i][j] - img1[i][j+1]), p*0.1) 
                                  + pow(fabs(img1[i][j] - img1[i][j+1]), p*0.1)) 
                        + (1/12.0) * (pow(fabs(img1[i][j] - img1[i-1][j-1]), p*0.1) 
                                    + pow(fabs(img1[i][j] - img1[i-1][j+1]), p*0.1) 
                                    + pow(fabs(img1[i][j] - img1[i+1][j+1]), p*0.1) 
                                    + pow(fabs(img1[i][j] - img1[i+1][j-1]), p*0.1));
        }
        sigma_ML[p] = sigma_ML[p]/ (2.0*(input_img.height-2)*(input_img.width-2));
        sigma_ML[p] = pow(sigma_ML[p], 1/(p*0.1));
        printf("when p = %f : sigma = %f\n", p*0.1, sigma_ML[p]);
    }    

    /* de-allocate space which was used for the images */   
    free_TIFF ( &(input_img) );
    free_TIFF ( &(output_img) );

    free_img( (void**)img1 );
    free_img( (void**)img2 );  
    free_img( (void**)perr );

    return(0);
}


void error(char *name)
{
    printf("usage:  %s  image.tiff \n\n",name);
    printf("this program reads in a 24-bit color TIFF image.\n");
    printf("It then horizontally filters the green component, adds noise,\n");
    printf("and writes out the result as an 8-bit image\n");
    printf("with the name 'green.tiff'.\n");
    printf("It also generates an 8-bit color image,\n");
    printf("that swaps red and green components from the input image");
    exit(1);
}
